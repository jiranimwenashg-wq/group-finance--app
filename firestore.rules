/**
 * @file Firestore Security Rules
 * @description This ruleset enforces a strict group-centric security model.
 *
 * Data Structure:
 * All data is nested under /groups/{groupId}, reflecting a community group-based application.
 * - /groups/{groupId}: Group details.
 * - /groups/{groupId}/users/{userId}: User details within a group.
 * - /groups/{groupId}/transactions/{transactionId}: Financial transactions.
 * - /groups/{groupId}/members/{memberId}: Group member details.
 * - /groups/{groupId}/insurancePolicies/{insurancePolicyId}: Insurance policies for the group.
 * - /groups/{groupId}/members/{memberId}/insurancePayments/{insurancePaymentId}: Insurance payments made by members.
 * - /groups/{groupId}/constitutions/{constitutionId}: The group's constitution document.
 * - /groups/{groupId}/savingsSchedules/{savingsScheduleId}: Savings schedules for the group.
 *
 * Key Security Decisions:
 * - No user listing is allowed at the top level.
 * - Access to all data is restricted to authenticated users.
 * - All data access is enforced based on group membership.
 *
 * Denormalization for Authorization:
 * - The 'groupId' is present on all documents nested under a group. This allows rules to quickly
 *   verify that the requested document belongs to the group specified in the path, without needing
 *   extra 'get()' operations.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Checks if the user is signed in.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * @description Checks if the authenticated user's ID matches the provided userId.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * @description Checks if the authenticated user is a valid group member for write operations.
     * @details This function checks that the group ID in the path matches the `groupId` in the resource data.
     */
    function isValidGroupMemberForWrite(groupId) {
      return isSignedIn() && request.resource.data.groupId == groupId;
    }

    /**
     * @description Checks if the authenticated user is a valid group member for update or delete operations.
     * @details This function checks that the group ID in the path matches the `groupId` in the existing resource data.
     */
    function isValidGroupMemberForUpdateAndDelete(groupId) {
        return isSignedIn() && resource.data.groupId == groupId;
    }

    /**
     * @description Groups are the root-level entity. Any signed-in user can create a group.
     * @path /groups/{groupId}
     * @allow (create) - Authenticated user creates a new group with a unique ID.
     *    - Request: auth.uid = "user123", resource.data.id = "group456"
     * @deny (create) - Unauthenticated user tries to create a group.
     *    - Request: auth.uid = null, resource.data.id = "group456"
     * @principle Allows authenticated users to create groups, enforcing basic authentication.
     */
    match /groups/{groupId} {
      allow get: if isSignedIn();
      allow list: if false; // Prevent listing all groups.

      allow create: if isSignedIn() && request.resource.data.id == groupId;
      allow update: if isSignedIn() && request.resource.data.id == groupId;
      allow delete: if false;
    }

    /**
     * @description Controls access to user documents within a group. Each user document is specific to a group.
     * @path /groups/{groupId}/users/{userId}
     * @allow (create) - User creates their own profile within a specific group.
     *    - Request: auth.uid = "user123", resource.data.id = "user123", resource.data.groupId = "group456"
     * @deny (create) - User tries to create a profile with a mismatched user ID.
     *    - Request: auth.uid = "user123", resource.data.id = "user456", resource.data.groupId = "group456"
     * @principle Enforces document ownership for writes; users can only create/modify their own documents.
     */
    match /groups/{groupId}/users/{userId} {
      allow get: if isSignedIn() && isOwner(userId);
      allow list: if false;

      allow create: if isOwner(userId) && request.resource.data.groupId == groupId;
      allow update: if isOwner(userId) && request.resource.data.groupId == groupId && request.resource.data.id == resource.data.id;
      allow delete: if isOwner(userId) && resource.data.groupId == groupId;
    }

    /**
     * @description Controls access to transaction documents within a group. Transactions are scoped to a specific group.
     * @path /groups/{groupId}/transactions/{transactionId}
     * @allow (create) - Authenticated user creates a new transaction within a specific group.
     *    - Request: auth.uid = "user123", resource.data.groupId = "group456"
     * @deny (create) - User tries to create a transaction for a different group.
     *    - Request: auth.uid = "user123", resource.data.groupId = "group789"
     * @principle Restricts access to transactions based on group membership; enforces group-level scoping.
     */
    match /groups/{groupId}/transactions/{transactionId} {
      allow get: if isSignedIn() && isValidGroupMemberForUpdateAndDelete(groupId);
      allow list: if isSignedIn() && isValidGroupMemberForUpdateAndDelete(groupId);

      allow create: if isSignedIn() && isValidGroupMemberForWrite(groupId);
      allow update: if isSignedIn() && isValidGroupMemberForUpdateAndDelete(groupId);
      allow delete: if isSignedIn() && isValidGroupMemberForUpdateAndDelete(groupId);
    }

    /**
     * @description Controls access to member documents within a group. Members are specific to a group.
     * @path /groups/{groupId}/members/{memberId}
     * @allow (create) - Authenticated user creates a new member within a specific group.
     *    - Request: auth.uid = "user123", resource.data.groupId = "group456"
     * @deny (create) - User tries to create a member for a different group.
     *    - Request: auth.uid = "user123", resource.data.groupId = "group789"
     * @principle Restricts access to members based on group membership; enforces group-level scoping.
     */
    match /groups/{groupId}/members/{memberId} {
      allow get: if isSignedIn() && isValidGroupMemberForUpdateAndDelete(groupId);
      allow list: if isSignedIn() && isValidGroupMemberForUpdateAndDelete(groupId);

      allow create: if isSignedIn() && isValidGroupMemberForWrite(groupId);
      allow update: if isSignedIn() && isValidGroupMemberForUpdateAndDelete(groupId);
      allow delete: if isSignedIn() && isValidGroupMemberForUpdateAndDelete(groupId);
    }

    /**
     * @description Controls access to insurance policy documents within a group. Insurance policies are scoped to a specific group.
     * @path /groups/{groupId}/insurancePolicies/{insurancePolicyId}
     * @allow (create) - Authenticated user creates a new insurance policy within a specific group.
     *    - Request: auth.uid = "user123", resource.data.groupId = "group456"
     * @deny (create) - User tries to create an insurance policy for a different group.
     *    - Request: auth.uid = "user123", resource.data.groupId = "group789"
     * @principle Restricts access to insurance policies based on group membership; enforces group-level scoping.
     */
    match /groups/{groupId}/insurancePolicies/{insurancePolicyId} {
      allow get: if isSignedIn() && isValidGroupMemberForUpdateAndDelete(groupId);
      allow list: if isSignedIn() && isValidGroupMemberForUpdateAndDelete(groupId);

      allow create: if isSignedIn() && isValidGroupMemberForWrite(groupId);
      allow update: if isSignedIn() && isValidGroupMemberForUpdateAndDelete(groupId);
      allow delete: if isSignedIn() && isValidGroupMemberForUpdateAndDelete(groupId);
    }

    /**
     * @description Controls access to insurance payment documents within a member's insurance payments.
     * @path /groups/{groupId}/members/{memberId}/insurancePayments/{insurancePaymentId}
     * @allow (create) - Authenticated user creates a new insurance payment.
     *    - Request: auth.uid = "user123", resource.data.memberId = "member456"
     * @deny (create) - User tries to create an insurance payment for a different member.
     *    - Request: auth.uid = "user123", resource.data.memberId = "member789"
     * @principle Restricts access to insurance payments based on member's group membership.
     */
    match /groups/{groupId}/members/{memberId}/insurancePayments/{insurancePaymentId} {
      allow get: if isSignedIn() && isValidGroupMemberForUpdateAndDelete(groupId);
      allow list: if isSignedIn() && isValidGroupMemberForUpdateAndDelete(groupId);

      allow create: if isSignedIn() && isValidGroupMemberForWrite(groupId);
      allow update: if isSignedIn() && isValidGroupMemberForUpdateAndDelete(groupId);
      allow delete: if isSignedIn() && isValidGroupMemberForUpdateAndDelete(groupId);
    }

    /**
     * @description Controls access to constitution documents within a group.
     * @path /groups/{groupId}/constitutions/{constitutionId}
     * @allow (create) - Authenticated user creates a new constitution document within a specific group.
     *    - Request: auth.uid = "user123", resource.data.groupId = "group456"
     * @deny (create) - User tries to create a constitution document for a different group.
     *    - Request: auth.uid = "user123", resource.data.groupId = "group789"
     * @principle Restricts access to constitution documents based on group membership; enforces group-level scoping.
     */
    match /groups/{groupId}/constitutions/{constitutionId} {
      allow get: if isSignedIn() && isValidGroupMemberForUpdateAndDelete(groupId);
      allow list: if isSignedIn() && isValidGroupMemberForUpdateAndDelete(groupId);

      allow create: if isSignedIn() && isValidGroupMemberForWrite(groupId);
      allow update: if isSignedIn() && isValidGroupMemberForUpdateAndDelete(groupId);
      allow delete: if isSignedIn() && isValidGroupMemberForUpdateAndDelete(groupId);
    }

    /**
     * @description Controls access to savings schedule documents within a group.
     * @path /groups/{groupId}/savingsSchedules/{savingsScheduleId}
     * @allow (create) - Authenticated user creates a new savings schedule within a specific group.
     *    - Request: auth.uid = "user123", resource.data.groupId = "group456"
     * @deny (create) - User tries to create a savings schedule for a different group.
     *    - Request: auth.uid = "user123", resource.data.groupId = "group789"
     * @principle Restricts access to savings schedule documents based on group membership; enforces group-level scoping.
     */
    match /groups/{groupId}/savingsSchedules/{savingsScheduleId} {
      allow get: if isSignedIn() && isValidGroupMemberForUpdateAndDelete(groupId);
      allow list: if isSignedIn() && isValidGroupMemberForUpdateAndDelete(groupId);

      allow create: if isSignedIn() && isValidGroupMemberForWrite(groupId);
      allow update: if isSignedIn() && isValidGroupMemberForUpdateAndDelete(groupId);
      allow delete: if isSignedIn() && isValidGroupMemberForUpdateAndDelete(groupId);
    }
  }
}